# Software Design - Software Assignment - Andrew Rozs
## The Github project can be found on this link: https://github.com/RYe01/sde-software-assignment

### Creational Patterns: These design patterns provide ways to create objects while hiding the creation logic, instead of instantiating objects directly using the new operator. This gives the program more flexibility in deciding which objects need to be created for a given use case.
### Structural Patterns: These design patterns deal with class and object composition. The concept of inheritance is used to compose interfaces and define ways to compose objects to obtain new functionality.
### Behavioral Patterns: These design patterns are specifically concerned with communication between objects.

In the code first we import all the necessary libraries like import ABC for calling the abstract method and import copy for using it in the prototype design pattern.
In line number 7 we create a class named as Prototype. Inside this class we make one method named as clone in which we simply return deep copy function from copy library. Prototype simple means making copies of functions. We pass one parameter in the constructor of concrete class which is named as value. Builder design pattern aim to reduce the object creation process's complexity and organize and improve these processes. The builder pattern pursues the same goal in its own unique situations. In the code we create a class named as computer in which we make constructor with a parameter serial-number. We initialize the values to memory hdd and gpu. After that we return info variable which stores the values in tuple. In this pattern we basically building the structure step by step like how we check things to purchase a laptop. In python def __init__ means constructor. Computer builder class return the value by calling the creating object of class Computer. Hardware is the concrete class in which we integrate all parts which we make in above classes like gpu hdd etc. Adapter pattern works as a bridge between two incompatible interfaces. This type of design pattern comes under structural pattern as this pattern combines the capability of two independent interfaces. In the code we make a class named as Fahrenheit-Thermometer in which we make constructor and initialize the value of temperature to 0. And get the temperature. In get function. After that we make a target interface class which is Celsius-Thermometer in which we initialize the value. And call it in the concrete class. The decorator pattern can be used to extend (decorate) the functionality of a certain object statically, or in some cases at run-time, independently of other instances of the same class, provided some groundwork is done at design time. In the code we make a class named as Decorator in which we declare the abstract method. In abstract method we simply declare the
function without defining it means the block code is empty like we did in the code pass. Next, we create a concrete class in which we define the function which we make in the interface class. In software design and engineering, the observer pattern is a software design pattern in which an object, named the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. In the code we make a class named as Subject. In this class we define the functions. Next we make class observer in which we declare the update function. After that we declare Command function and call all the functions in receiver. Similarly, we do all the below design patterns. In the main function if __run__==main we simple create objects of different design patterns and get the results.


